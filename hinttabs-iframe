// This one uses a blob as the source of the iframe and requires no js or messaging in the iframe doc
// because this creates a string for the html source, the data from the tabs (title, url, favIconUrl)
// can cause issues if they have html tags etc
// hintable elements are put into a grid with the same attributes as the iframe's tab grid so they line up with a bit of maths

tri.tabhintpopup = {};
const th = tri.tabhintpopup;

th.settings = {
    maxCols: 2,
    maxRows: 10,
    tabGridMargin: "auto",
    tabGridWidth: "80%",
    incogIconSrc: "chrome://global/skin/icons/indicator-private-browsing.svg",
    topMargin: "7rem",
    /* using em for the following allows easier calculation of eventual cell positions */
    gridGapEm: 0.42,
    iconSizeEm: 1,
    lineHeightEm: 1.5,
    cellPaddingTopEm: 0.5,
    cellPaddingBottomEm: 0.5,

    /* no effect right now */
    showCurrentTab: true,
    /* compareFn(a, b) */
    tabSortCompareFn: undefined,

    computed: getComputedStyle(document.documentElement),

    /* these undefined values will use --tridactyl css vars if not set here */
    titleFontFamily: undefined,
    urlFontFamily: undefined,

    titleFontColour: undefined,
    urlFontColour: undefined,

    titleFontSize: undefined,
    urlFontSize: undefined,

    cellBg: undefined

};

const s = th.settings;

/* set some defaults that use computed values */

s.titleFontFamily = s.titleFontFamily || s.computed.getPropertyValue('--tridactyl-cmdl-font-family');
s.urlFontFamily =  s.urlFontFamily || s.titleFontFamily;
s.titleFontColour = s.titleFontColour || s.computed.getPropertyValue('--tridactyl-cmdl-fg');
s.urlFontColour = s.urlFontColour || s.computed.getPropertyValue('--tridactyl-cmplt-fg');
s.titleFontSize = s.titleFontSize || s.computed.getPropertyValue('--tridactyl-cmdl-font-size');
s.urlFontSize = s.urlFontSize || s.titleFontSize;
s.cellBg = s.cellBg || s.computed.getPropertyValue('--tridactyl-cmdl-bg');



/* creating iframe source this way doesn't upset firefox  */
/* pieces together html source as a string then makes it into a blob to use as iframe source */

/* as far as I can tell tab titles/urls are all hidden away inside the iframe */

th.makeIframeHtml = async function (iframe, start = 0) {
    /* https://stackoverflow.com/questions/69591128/chrome-is-forcing-a-white-background-on-frames-only-on-some-websites */
    /* suggests there should be a way to fix non-transparent bg on sites like github by using the same colour scheme in header */

    /* could presumabely use a blob as css source as well to make styling easier but this just puts everything in a style tag */

    th.iframeHtmlStart = '<!DOCTYPE html><html><head><style> body { margin: auto; } #grid { width: 100%; display: grid; grid-template-columns: repeat('+s.maxCols+', 1fr); grid-gap:'+s.gridGapEm+'em; font-family:'+s.titleFontFamily+'; font-size:'+s.titleFontSize+' } p { overflow: clip; white-space: nowrap; text-overflow: ellipsis; padding: 0; margin: 0; line-height:'+s.lineHeightEm+'; } .title { color: '+s.titleFontColour+'; }.url { color: '+s.urlFontColour+'; font-family: '+s.urlFontFamily+'; font-size:'+s.urlFontSize+' } .icon { width:'+s.iconSizeEm+'em; padding-right: 1em; padding-left: 0.5em; } .tab-parent{ padding:'+s.cellPaddingTopEm+'em 1em '+s.cellPaddingBottomEm+'em 1em; overflow:clip; /* outline: solid 1px orange */; height: '+th.cellHeight+'em; } </style></head><body><div id="grid">';

    /* info from tabs goes between start and end */

    th.iframeHtmlEnd = '</div></body></html>';

    th.iframeHtml = th.iframeHtmlStart;

    for (let i = start; i < Math.min(th.maxVisibleCells, th.tabArray.length); ++i) {
        let tab = th.tabArray[i];
        let faviStyle = (th.tabArray[i].favIconUrl === undefined ? ' style="visibility:hidden"' : '');
        let incogStyle = (th.tabArray[i].incognito === undefined ? ' style="visibility:hidden"' : '');

        /* oh no do you need to sanitise favicon src as well ... that's a lot of text */

        th.iframeHtml += '<div class="tab-parent"><p class="title"><img class="icon favicon" src='+th.makeTextSafe(tab.favIconUrl)+faviStyle+'>'+th.makeTextSafe(tab.title)+'</p><p class="url"><img class="icon incogicon" src='+s.incogIconSrc+incogStyle+'>'+th.makeTextSafe(tab.url)+'</p></div>';
    }

    const blobContent = new Blob([th.iframeHtml], {type: "text/html"});
    th.blobRef = URL.createObjectURL(blobContent);
    iframe.src = th.blobRef;
    iframe.sandbox = "";

    /* parent div is just to make it easy to centre the iframe on the page */
    let parent = document.createElement("div");

    parent.style.position = "fixed";
    parent.style.width = "100%";
    parent.style.height = "100%";
    parent.style.top = 0;
    parent.style["margin-top"] = s.topMargin;
    parent.style["z-index"] = 2147483645;

    parent.appendChild(iframe);
    document.documentElement.appendChild(parent);

    th.iframeParent = parent;

    return iframe;
};


/* copied from tridactyl source */
th.goToTab = async function(tabId) {
    const tab = await tri.browserBg.tabs.update(tabId, { active: true });
    await tri.browserBg.windows.update(tab.windowId, { focused: true });
    return tab;
};

/* makes sense to make the tabs available like this I think */
th.populateTabArray = async function(bTabAll = false, start = 0) {
    th.tabArrayFull = await tri.browserBg.tabs.query(bTabAll ? {} : {currentWindow:true});
    if (th.tabSortComparisonFn !== undefined) {
        th.tabArrayFull.sort(tabSortCompareFn);
    }

    th.tabArray = th.tabArrayFull.slice(start);

    return th.tabArray;
};

/* necessary because of the way I'm currently creating the iframe source */
/* not necessary when setting textContent of grid cells but there is no js in the iframe atm */

th.makeTextSafe = function(unsafe) {
  if (unsafe === undefined) { return ""; }
  return unsafe.replaceAll("&", "&amp").replaceAll("<", "&lt").replaceAll(">", "&gt").replaceAll("\"", "&quot").replaceAll("'", "&#39");
};

th.makeHintGrid = async function() {
  let parent = document.createElement("div");

  parent.style.position = "fixed";
  parent.style.width = "100%";
  parent.style.top = 0;
  parent.style["margin-top"] = s.topMargin;
  parent.style["z-index"] = 2147483644; /* below hint spans, above iframe */

  let grid = document.createElement("div");

  grid.style.width = s.tabGridWidth;
  grid.style.height = "fit-content";
  grid.style.display = "grid";
  grid.style["grid-gap"] = s.gridGapEm + "em";
  grid.style["grid-template-columns"] = "repeat("+s.maxCols+", 1fr)";
  grid.style.margin = s.tabGridMargin;


  parent.appendChild(grid);
  document.documentElement.appendChild(parent);

  th.hintsParent = parent;

  grid.style["font-size"] = s.urlFontSize;
  let urlFontSizePx = parseFloat(getComputedStyle(grid).fontSize);

  grid.style["font-size"] = s.titleFontSize;
  let titleFontSizePx = parseFloat(getComputedStyle(grid).fontSize);
  
  let urlFontSizeEm = titleFontSizePx / urlFontSizePx;
  let fontSizeAvgPx = (urlFontSizePx + titleFontSizePx) / 2;

  th.cellHeight = Math.max(1, s.lineHeightEm, s.iconSizeEm) + Math.max(urlFontSizeEm, s.lineHeightEm, s.iconSizeEm);

  th.cellHeightPadded = th.cellHeight + s.cellPaddingTopEm + s.cellPaddingBottomEm;

  const cellSpacing = th.cellHeightPadded + s.gridGapEm;

  let topPx = grid.getBoundingClientRect().top;

  let maxRows = Math.max(1, Math.floor((window.innerHeight - topPx) / (cellSpacing * fontSizeAvgPx)));

  /* make this available to iframe function */
  th.maxVisibleCells = s.maxCols * Math.min(maxRows, s.maxRows);

  return grid;
};

/* hintables with associated tab ids */
th.makeHintables = async function (grid, start = 0) {
    th.numHintables = Math.min(th.maxVisibleCells, th.tabArray.length);

    for (let i = start; i < th.numHintables; ++i) {
        let hintCell = document.createElement("div");

        hintCell.className = "tri-tab-hint";
        hintCell.style.height = th.cellHeightPadded + "em";
        hintCell.tabid = th.tabArray[i].id;
        hintCell.style.outline = "solid 1px orange";
        hintCell.style.background = s.cellBg;

        grid.appendChild(hintCell);
    }

    return grid;
};


/* just to check this works with some quick fwd/back buttons */
th.makePrevNext = function() {
    let prev = document.createElement('div');
    prev.className = "tri-tab-hint";
    prev.id = "tri-tabs-prev";

    let next = document.createElement('div');
    next.className = "tri-tab-hint";
    next.id = "tri-tabs-next";

    prev.style.position = "fixed";
    prev.style.top = s.topMargin;
    prev.style.left = "2.5%";
    prev.style.width = "5%";
    prev.style["text-align"] = "center";

    next.style.position = "fixed";
    next.style.top = s.topMargin;
    next.style.left = "92.5%";
    next.style.width = "5%";
    next.style.height = "20px";
    next.style["text-align"] = "center";

    next.textContent = "-->";
    prev.textContent = "<--";

    next.style.background = s.cellBg;
    prev.style.background = s.cellBg;

    document.documentElement.appendChild(prev);
    document.documentElement.appendChild(next);
    
    th.prev = prev;
    th.next = next;
}

th.makeTabIframe = async function () {
  let iframe = document.createElement("iframe");

  iframe.sandbox = "allow-same-origin";

  iframe.style.border = "none";
  iframe.style.height = "100%";

  /* common with hint grid */
  iframe.style.width = s.tabGridWidth;
  iframe.style.margin = s.tabGridMargin;

  iframe.style.display = "block";

  return iframe;
};

/* ideally you wouldn't make everything from scratch every time but this works eh */
th.cleanup = function() {
    th.hintsParent.remove();
    th.iframeParent.remove();
    th.prev.remove();
    th.next.remove();
    URL.revokeObjectURL(th.blobRef);
};

th.hint = async function(bTabAll = false, start = 0) {
    let tabs = await th.populateTabArray(bTabAll, start);
    th.makePrevNext();

    th.makeTabIframe().then((iframe)=>th.makeIframeHtml(iframe));
    th.makeHintGrid().then((grid)=>th.makeHintables(grid).then(function() {
        tri.excmds.hint("-c", ".tri-tab-hint").then(function(el) {
            if (el.tabid !== undefined) {
                th.goToTab(el.tabid);
            }
            else if (el.id === "tri-tabs-next") {
                let newStart = (start + th.numHintables < th.tabArrayFull.length ? start + th.numHintables : start);
                th.hint(bTabAll, newStart)
            }
            else if (el.id === "tri-tabs-prev") {
                th.hint(bTabAll, Math.max(0, start - th.maxVisibleCells));
            }
            th.cleanup();
        })
    }));
};

th.hint(true);
